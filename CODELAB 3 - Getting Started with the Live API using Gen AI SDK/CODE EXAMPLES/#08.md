# Example 8: Code Execution with Live API

This example demonstrates how to use the Live API's code execution capability to generate and run Python code.

````python
import asyncio
from google import genai
from google.genai.types import LiveConnectConfig, Content, Part, Tool, ToolCodeExecution
from IPython.display import Markdown, display

async def code_execution_example():
    # Initialize the client (assuming it's already been set up)
    # client = genai.Client(vertexai=True, project=PROJECT_ID, location=LOCATION)

    # Set the model
    MODEL_ID = "gemini-2.0-flash-live-preview-04-09"

    # Configure the session with code execution tool
    config = LiveConnectConfig(
        response_modalities=["TEXT"],
        tools=[Tool(code_execution=ToolCodeExecution())],
    )

    # Create the session
    async with client.aio.live.connect(
        model=MODEL_ID,
        config=config,
    ) as session:
        # Define a prompt that should trigger code generation and execution
        text_input = "Write tool code to calculate the 15th fibonacci number then find the nearest palindrome to it"
        display(Markdown(f"**Input:** {text_input}"))

        # Send the input to the model
        await session.send_client_content(
            turns=Content(role="user", parts=[Part(text=text_input)])
        )

        # Collect text response
        response = []

        # Process the response stream
        async for message in session.receive():
            # Collect any regular text responses
            if message.text:
                response.append(message.text)

            # Process model turn parts for code and execution results
            if message.server_content.model_turn:
                if message.server_content.model_turn.parts:
                    for part in message.server_content.model_turn.parts:
                        # Display generated executable code
                        if part.executable_code:
                            display(
                                Markdown(
                                    f"""
**Executable code:**
```python
{part.executable_code.code}
````

"""
)
)

                        # Display code execution results
                        if part.code_execution_result:
                            display(
                                Markdown(
                                    f"""

**Code execution result:**

```
{part.code_execution_result.output}
```

"""
)
)

        # Display the complete text response
        display(Markdown(f"**Complete response:** {''.join(response)}"))

# Run the example (in a notebook, you would use await code_execution_example())

# asyncio.run(code_execution_example())

```

## Explanation

This code demonstrates how to use the code execution capability of the Gemini Live API:

1. **Tool Configuration**:
   - Sets up the code execution tool using `Tool(code_execution=ToolCodeExecution())`
   - Includes this tool in the `LiveConnectConfig` to enable code generation and execution
   - The code execution tool allows Gemini to write and run Python code in a secure sandbox

2. **Prompt Design**:
   - Uses a prompt that specifically asks for code generation and execution
   - The prompt is clear about the computational task (calculate Fibonacci number and find nearest palindrome)
   - Well-structured prompts help the model generate more accurate and relevant code

3. **Response Processing**:
   - Monitors the response stream for different types of content:
     - Regular text responses via `message.text`
     - Executable code via `part.executable_code`
     - Code execution results via `part.code_execution_result`
   - Displays each type of content appropriately with markdown formatting

4. **Key Components in Response Handling**:
   - `executable_code`: Contains the Python code generated by the model
   - `code_execution_result`: Contains the output from running the code
   - Both are presented to the user with proper formatting

5. **Security Considerations**:
   - Code execution happens in a controlled sandbox environment
   - The sandbox has limitations on:
     - Execution time
     - Available libraries
     - Network access
     - System resource usage

This capability is particularly useful for:
- Data analysis and visualization tasks
- Algorithmic problem solving
- Teaching programming concepts
- Automating computational workflows

The code execution feature makes Gemini more powerful for technical scenarios where computation is needed, allowing it to not just suggest code but also demonstrate the results.
```
